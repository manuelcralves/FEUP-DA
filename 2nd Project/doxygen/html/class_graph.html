<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>G16_3 Programming Project II: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">G16_3 Programming Project II<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Routing Algorithm for Ocean Shipping and Urban Deliveries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a902c5b3eacb66d60752525ab23297a95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a902c5b3eacb66d60752525ab23297a95">~Graph</a> ()</td></tr>
<tr class="separator:a902c5b3eacb66d60752525ab23297a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f7fc73ea9976295d387846ad36c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a089f7fc73ea9976295d387846ad36c69">findVertex</a> (const int &amp;id) const</td></tr>
<tr class="separator:a089f7fc73ea9976295d387846ad36c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df91d53fcd35d0e526fbc4201274db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8df91d53fcd35d0e526fbc4201274db0">addVertex</a> (const int &amp;id, const double &amp;lon, const double &amp;lat)</td></tr>
<tr class="separator:a8df91d53fcd35d0e526fbc4201274db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ecf6809d431683bee76d78eb4d717"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a082ecf6809d431683bee76d78eb4d717">addEdge</a> (const int &amp;sourc, const int &amp;dest, double w) const</td></tr>
<tr class="separator:a082ecf6809d431683bee76d78eb4d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32ab67cf90a32b62278f685f8c51b98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af32ab67cf90a32b62278f685f8c51b98">addBidirectionalEdge</a> (const int &amp;sourc, const int &amp;dest, double w) const</td></tr>
<tr class="separator:af32ab67cf90a32b62278f685f8c51b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6a7016cb63fae941f9db1e64778ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4d6a7016cb63fae941f9db1e64778ce7">backtrack</a> (int currentVertex, std::vector&lt; int &gt; &amp;currentPath, double currentCost)</td></tr>
<tr class="memdesc:a4d6a7016cb63fae941f9db1e64778ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtracking algorithm to find the best path in a graph. This function is recursive and it is used to find the best path using the backtracking algorithm. Starting from a given current vertex, it explores all possible paths by recursively traversing the neighboring vertices. It keeps track of the current path and cost, updating the best path and cost whenever a complete cycle (path) is formed.  <br /></td></tr>
<tr class="separator:a4d6a7016cb63fae941f9db1e64778ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abb5e0517e2979c54eebdafc2a9875e8f">getNumVertex</a> () const</td></tr>
<tr class="separator:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619ac583094079134074658e29463c0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a619ac583094079134074658e29463c0e">getVertexSet</a> () const</td></tr>
<tr class="separator:a619ac583094079134074658e29463c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad179cbc8be49bddafc6dd56808b7303f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad179cbc8be49bddafc6dd56808b7303f">getBestPath</a> () const</td></tr>
<tr class="separator:ad179cbc8be49bddafc6dd56808b7303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a916c1d4af18fd3f97bb329840d632f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0a916c1d4af18fd3f97bb329840d632f">getBestCost</a> () const</td></tr>
<tr class="separator:a0a916c1d4af18fd3f97bb329840d632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94298b826225b9f4a4a1ce7d27536c52"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a94298b826225b9f4a4a1ce7d27536c52">findMinimumSpanningTree</a> (std::vector&lt; int &gt; &amp;<a class="el" href="_mutable_priority_queue_8h.html#a915a9564b15f2c25e828da2e9a05769c">parent</a>)</td></tr>
<tr class="memdesc:a94298b826225b9f4a4a1ce7d27536c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum spanning tree using Prim's algorithm. This function finds the minimum spanning tree (MST) of the graph using Prim's algorithm. It starts from a specified start vertex and iteratively adds the minimum-weight edges that connect the already visited vertices to the newly visited vertices. The function returns a vector of pairs representing the edges of the minimum spanning tree.  <br /></td></tr>
<tr class="separator:a94298b826225b9f4a4a1ce7d27536c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6255e27a2250f78b65e308eb4e7903"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ada6255e27a2250f78b65e308eb4e7903">areVerticesConnected</a> (int vertex1, int vertex2)</td></tr>
<tr class="memdesc:ada6255e27a2250f78b65e308eb4e7903"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two vertices are connected.  <br /></td></tr>
<tr class="separator:ada6255e27a2250f78b65e308eb4e7903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f03efeb8ce9f2ae510b255430271a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a05f03efeb8ce9f2ae510b255430271a4">calculateTotalDistance</a> (const std::vector&lt; int &gt; &amp;route)</td></tr>
<tr class="memdesc:a05f03efeb8ce9f2ae510b255430271a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total distance of a route. This function calculates the total distance of a route.  <br /></td></tr>
<tr class="separator:a05f03efeb8ce9f2ae510b255430271a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac3915ab78762e537d45657e30429b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a74ac3915ab78762e537d45657e30429b">triangularApproximation</a> ()</td></tr>
<tr class="memdesc:a74ac3915ab78762e537d45657e30429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the total distance of a route using the triangular approximation algorithm. This function calculates the total distance of a route using the triangular approximation algorithm.  <br /></td></tr>
<tr class="separator:a74ac3915ab78762e537d45657e30429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e0acd93275a00a011bfa5f6c624d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a716e0acd93275a00a011bfa5f6c624d0">nearestNeighbor</a> (<a class="el" href="class_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a716e0acd93275a00a011bfa5f6c624d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the best path using the nearest neighbor algorithm. This function calculates the total distance of a route using the nearest neighbor algorithm.  <br /></td></tr>
<tr class="separator:a716e0acd93275a00a011bfa5f6c624d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a800d17f2cb4a6780513838aaf93c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5a800d17f2cb4a6780513838aaf93c0d">tabuSearch</a> (<a class="el" href="class_graph.html">Graph</a> &amp;graph, int maxIterations, int tabuListSize, int maxIterationsWithoutImprovement)</td></tr>
<tr class="memdesc:a5a800d17f2cb4a6780513838aaf93c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Tabu Search algorithm to find an improved solution. This function implements the Tabu Search algorithm to find an improved solution for a given graph. It iteratively generates neighboring solutions and evaluates their costs. The algorithm maintains a tabu list to prevent revisiting previously visited solutions. If a better neighbor solution is found and it is not in the tabu list, it becomes the current solution. The algorithm stops when either the maximum number of iterations is reached or no improvement is made for a certain number of iterations.  <br /></td></tr>
<tr class="separator:a5a800d17f2cb4a6780513838aaf93c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff2dbf5f385f7b22894b9ec290c0eb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aaff2dbf5f385f7b22894b9ec290c0eb4">isTabuAspirational</a> (const std::vector&lt; int &gt; &amp;solution, const std::deque&lt; std::vector&lt; int &gt; &gt; &amp;tabuList, const double diversificationThreshold)</td></tr>
<tr class="memdesc:aaff2dbf5f385f7b22894b9ec290c0eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a solution is tabu aspirational. This function checks if a solution is tabu aspirational by comparing it with the solutions in the tabu list. A solution is tabu aspirational if its diversity with any of the solutions in the tabu list is greater than the diversification threshold.  <br /></td></tr>
<tr class="separator:aaff2dbf5f385f7b22894b9ec290c0eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d78c739188d98a06e1ff3d79a584a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab7d78c739188d98a06e1ff3d79a584a2">isTabu</a> (const std::vector&lt; int &gt; &amp;solution, const std::deque&lt; std::vector&lt; int &gt; &gt; &amp;tabuList)</td></tr>
<tr class="memdesc:ab7d78c739188d98a06e1ff3d79a584a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a solution is tabu. This function checks if a solution is tabu by comparing it with the solutions in the tabu list.  <br /></td></tr>
<tr class="separator:ab7d78c739188d98a06e1ff3d79a584a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb86b8087bea43a76f8efa604139b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afacb86b8087bea43a76f8efa604139b6">generateRandomSolution</a> ()</td></tr>
<tr class="memdesc:afacb86b8087bea43a76f8efa604139b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random solution for the graph. This function generates a random solution for the graph by randomly shuffling the vertices.  <br /></td></tr>
<tr class="separator:afacb86b8087bea43a76f8efa604139b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac352130e3587cea1598abbe6a1175384"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac352130e3587cea1598abbe6a1175384">generateNeighborSolution</a> (const std::vector&lt; int &gt; &amp;solution)</td></tr>
<tr class="memdesc:ac352130e3587cea1598abbe6a1175384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a neighboring solution based on a given solution. This function generates a neighboring solution by applying a random mutation to the given solution. The mutation can be one of four types: swap, deletion, reversal, or scramble.  <br /></td></tr>
<tr class="separator:ac352130e3587cea1598abbe6a1175384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961b73cac0c31b9f472b9441a713d1f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a961b73cac0c31b9f472b9441a713d1f2">simulatedAnnealing</a> (<a class="el" href="class_graph.html">Graph</a> &amp;graph, int maxIterations, double initialTemperature, double coolingRate)</td></tr>
<tr class="memdesc:a961b73cac0c31b9f472b9441a713d1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Simulated Annealing algorithm on the graph. This function applies the Simulated Annealing algorithm to find an optimal solution for the given graph. It starts with an initial solution and iteratively explores neighboring solutions by accepting or rejecting them based on a probability. The algorithm aims to converge towards the global optimum by gradually decreasing the acceptance probability with each iteration.  <br /></td></tr>
<tr class="separator:a961b73cac0c31b9f472b9441a713d1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9105821b1b565a16fd6a917dd844a10"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae9105821b1b565a16fd6a917dd844a10">acceptanceProbability</a> (double currentCost, double candidateCost, double temperature)</td></tr>
<tr class="memdesc:ae9105821b1b565a16fd6a917dd844a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceptance probability for a candidate solution.  <br /></td></tr>
<tr class="separator:ae9105821b1b565a16fd6a917dd844a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef310ea9f68e12bd1f60c18fddad26d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adef310ea9f68e12bd1f60c18fddad26d">generateNeighbors</a> (const std::vector&lt; int &gt; &amp;solution)</td></tr>
<tr class="separator:adef310ea9f68e12bd1f60c18fddad26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f960002a46dced00b8576d945b3cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a628f960002a46dced00b8576d945b3cf">evaluateSolution</a> (<a class="el" href="class_graph.html">Graph</a> &amp;graph, const std::vector&lt; int &gt; &amp;solution)</td></tr>
<tr class="memdesc:a628f960002a46dced00b8576d945b3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a solution for the graph. This function evaluates a solution for the graph by calculating the total cost of the solution.  <br /></td></tr>
<tr class="separator:a628f960002a46dced00b8576d945b3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f002e63b0aaac8c6806c23c629c836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a55f002e63b0aaac8c6806c23c629c836">constructMST</a> (<a class="el" href="class_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a55f002e63b0aaac8c6806c23c629c836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a minimum spanning tree for the graph. This function constructs a minimum spanning tree for the graph.  <br /></td></tr>
<tr class="separator:a55f002e63b0aaac8c6806c23c629c836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9909acdfa72e74a26128514c8d4347"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8e9909acdfa72e74a26128514c8d4347">findVerticesWithOddDegrees</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;mstGraph)</td></tr>
<tr class="memdesc:a8e9909acdfa72e74a26128514c8d4347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertices with odd degrees in the graph. This function finds the vertices with odd degrees in the graph.  <br /></td></tr>
<tr class="separator:a8e9909acdfa72e74a26128514c8d4347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7de765e6857b5c27c468d116b54303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afa7de765e6857b5c27c468d116b54303">findMinimumWeightMatching</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;graph, const std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;oddDegreeVertices)</td></tr>
<tr class="memdesc:afa7de765e6857b5c27c468d116b54303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum weight matching for the graph. This function finds the minimum weight matching for the graph.  <br /></td></tr>
<tr class="separator:afa7de765e6857b5c27c468d116b54303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff5be234d0d81cdd1990a5449c74c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5ff5be234d0d81cdd1990a5449c74c50">combineGraphs</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;mstGraph, const <a class="el" href="class_graph.html">Graph</a> &amp;matchingGraph)</td></tr>
<tr class="memdesc:a5ff5be234d0d81cdd1990a5449c74c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the minimum spanning tree and the minimum weight matching. This function combines the minimum spanning tree and the minimum weight matching.  <br /></td></tr>
<tr class="separator:a5ff5be234d0d81cdd1990a5449c74c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaf9785bb3717ce22b6570286179fb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7eaf9785bb3717ce22b6570286179fb1">findEulerianCircuit</a> (<a class="el" href="class_graph.html">Graph</a> &amp;multigraph)</td></tr>
<tr class="memdesc:a7eaf9785bb3717ce22b6570286179fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an Eulerian circuit for the multigraph. This function finds an Eulerian circuit for the multigraph.  <br /></td></tr>
<tr class="separator:a7eaf9785bb3717ce22b6570286179fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62e7d089926d34b8cac9b7cd3ccd88b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa62e7d089926d34b8cac9b7cd3ccd88b">removeDuplicates</a> (const std::vector&lt; int &gt; &amp;eulerianCircuit)</td></tr>
<tr class="memdesc:aa62e7d089926d34b8cac9b7cd3ccd88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate vertices from the Eulerian circuit.  <br /></td></tr>
<tr class="separator:aa62e7d089926d34b8cac9b7cd3ccd88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5db6e0f2ce3b90d05a7335cc064ed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af7a5db6e0f2ce3b90d05a7335cc064ed">getEdgeWeight</a> (int source, int destination) const</td></tr>
<tr class="memdesc:af7a5db6e0f2ce3b90d05a7335cc064ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge weight between two vertices.  <br /></td></tr>
<tr class="separator:af7a5db6e0f2ce3b90d05a7335cc064ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9d3c4a58a1512934ca50e9d23a7c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#add9d3c4a58a1512934ca50e9d23a7c83">christofidesAlgorithm</a> (<a class="el" href="class_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:add9d3c4a58a1512934ca50e9d23a7c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the Christofides algorithm. This function implements the Christofides algorithm.  <br /></td></tr>
<tr class="separator:add9d3c4a58a1512934ca50e9d23a7c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c8ef3f68bab7aa3c826b6f755396c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac6c8ef3f68bab7aa3c826b6f755396c7">MST</a> ()</td></tr>
<tr class="memdesc:ac6c8ef3f68bab7aa3c826b6f755396c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a minimum spanning tree for the graph. This function constructs a minimum spanning tree for the graph.  <br /></td></tr>
<tr class="separator:ac6c8ef3f68bab7aa3c826b6f755396c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a072430e1f6120bf79e19ad38dc556aa5"><td class="memItemLeft" align="right" valign="top">static static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a072430e1f6120bf79e19ad38dc556aa5">dfs</a> (int currentVertex, const std::vector&lt; int &gt; &amp;<a class="el" href="_mutable_priority_queue_8h.html#a915a9564b15f2c25e828da2e9a05769c">parent</a>, std::vector&lt; bool &gt; &amp;visited, std::stack&lt; int &gt; &amp;vertexStack, std::vector&lt; int &gt; &amp;route)</td></tr>
<tr class="memdesc:a072430e1f6120bf79e19ad38dc556aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a depth-first search (DFS) traversal of the graph. This function performs a depth-first search (DFS) traversal of the graph, starting at the specified vertex. The DFS traversal is implemented iteratively using a stack.  <br /></td></tr>
<tr class="separator:a072430e1f6120bf79e19ad38dc556aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7dfcef08a9286cf144902cd7e56940ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7dfcef08a9286cf144902cd7e56940ee">findVertexIdx</a> (const int &amp;id) const</td></tr>
<tr class="separator:a7dfcef08a9286cf144902cd7e56940ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa9b0a6d8ad43c5eabaca5a7140bcc8b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9b0a6d8ad43c5eabaca5a7140bcc8b6">vertexSet</a></td></tr>
<tr class="separator:aa9b0a6d8ad43c5eabaca5a7140bcc8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e099ad9b42cb93771db6b434bc6693"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad4e099ad9b42cb93771db6b434bc6693">bestPath</a></td></tr>
<tr class="separator:ad4e099ad9b42cb93771db6b434bc6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f00b32afb4745db9d4d415003500579"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9f00b32afb4745db9d4d415003500579">bestCost</a> = std::numeric_limits&lt;double&gt;::max()</td></tr>
<tr class="separator:a9f00b32afb4745db9d4d415003500579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61864da69191c1896a25a708d1a02d"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9e61864da69191c1896a25a708d1a02d">distMatrix</a> = nullptr</td></tr>
<tr class="separator:a9e61864da69191c1896a25a708d1a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3ae09699c3616af3ebfcb1eb045f2b62">pathMatrix</a> = nullptr</td></tr>
<tr class="separator:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a902c5b3eacb66d60752525ab23297a95" name="a902c5b3eacb66d60752525ab23297a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902c5b3eacb66d60752525ab23297a95">&#9670;&#160;</a></span>~Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::~Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9105821b1b565a16fd6a917dd844a10" name="ae9105821b1b565a16fd6a917dd844a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9105821b1b565a16fd6a917dd844a10">&#9670;&#160;</a></span>acceptanceProbability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::acceptanceProbability </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currentCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>candidateCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>temperature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the acceptance probability for a candidate solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentCost</td><td></td></tr>
    <tr><td class="paramname">candidateCost</td><td></td></tr>
    <tr><td class="paramname">temperature</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af32ab67cf90a32b62278f685f8c51b98" name="af32ab67cf90a32b62278f685f8c51b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32ab67cf90a32b62278f685f8c51b98">&#9670;&#160;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a082ecf6809d431683bee76d78eb4d717" name="a082ecf6809d431683bee76d78eb4d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ecf6809d431683bee76d78eb4d717">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8df91d53fcd35d0e526fbc4201274db0" name="a8df91d53fcd35d0e526fbc4201274db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df91d53fcd35d0e526fbc4201274db0">&#9670;&#160;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada6255e27a2250f78b65e308eb4e7903" name="ada6255e27a2250f78b65e308eb4e7903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6255e27a2250f78b65e308eb4e7903">&#9670;&#160;</a></span>areVerticesConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::areVerticesConnected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if two vertices are connected. </p>
<dl class="section note"><dt>Note</dt><dd>complexity: O(n) n is the number of edges in the graph; </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex1</td><td></td></tr>
    <tr><td class="paramname">vertex2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4d6a7016cb63fae941f9db1e64778ce7" name="a4d6a7016cb63fae941f9db1e64778ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6a7016cb63fae941f9db1e64778ce7">&#9670;&#160;</a></span>backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::backtrack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>currentPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currentCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backtracking algorithm to find the best path in a graph. This function is recursive and it is used to find the best path using the backtracking algorithm. Starting from a given current vertex, it explores all possible paths by recursively traversing the neighboring vertices. It keeps track of the current path and cost, updating the best path and cost whenever a complete cycle (path) is formed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentVertex</td><td>The current vertex being visited. </td></tr>
    <tr><td class="paramname">currentPath</td><td>The current path being constructed. </td></tr>
    <tr><td class="paramname">currentCost</td><td>The current cost of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The complexity of the backtracking algorithm depends on the size and structure of the graph. In the worst case, where every vertex is connected to every other vertex, the number of possible paths to explore grows factorially with the number of vertices. Therefore, the complexity can be expressed as O((n-1)!), where n is the number of vertices in the graph. It is important to note that the backtracking algorithm can be computationally expensive for large graphs, and alternative algorithms such as dynamic programming or heuristics may be more efficient in those cases. </dd></dl>

</div>
</div>
<a id="a05f03efeb8ce9f2ae510b255430271a4" name="a05f03efeb8ce9f2ae510b255430271a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f03efeb8ce9f2ae510b255430271a4">&#9670;&#160;</a></span>calculateTotalDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculateTotalDistance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total distance of a route. This function calculates the total distance of a route. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">route</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>complexity: O(n) n is the number of vertices in the graph; </dd></dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="add9d3c4a58a1512934ca50e9d23a7c83" name="add9d3c4a58a1512934ca50e9d23a7c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9d3c4a58a1512934ca50e9d23a7c83">&#9670;&#160;</a></span>christofidesAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::christofidesAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the Christofides algorithm. This function implements the Christofides algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>complexity: O(V^3) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff5be234d0d81cdd1990a5449c74c50" name="a5ff5be234d0d81cdd1990a5449c74c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff5be234d0d81cdd1990a5449c74c50">&#9670;&#160;</a></span>combineGraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::combineGraphs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>mstGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>matchingGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine the minimum spanning tree and the minimum weight matching. This function combines the minimum spanning tree and the minimum weight matching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mstGraph</td><td></td></tr>
    <tr><td class="paramname">matchingGraph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a55f002e63b0aaac8c6806c23c629c836" name="a55f002e63b0aaac8c6806c23c629c836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f002e63b0aaac8c6806c23c629c836">&#9670;&#160;</a></span>constructMST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::constructMST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a minimum spanning tree for the graph. This function constructs a minimum spanning tree for the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A minimum spanning tree for the graph. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a072430e1f6120bf79e19ad38dc556aa5" name="a072430e1f6120bf79e19ad38dc556aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072430e1f6120bf79e19ad38dc556aa5">&#9670;&#160;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a depth-first search (DFS) traversal of the graph. This function performs a depth-first search (DFS) traversal of the graph, starting at the specified vertex. The DFS traversal is implemented iteratively using a stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentVertex</td><td></td></tr>
    <tr><td class="paramname">parent</td><td></td></tr>
    <tr><td class="paramname">visited</td><td></td></tr>
    <tr><td class="paramname">vertexStack</td><td></td></tr>
    <tr><td class="paramname">route</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a628f960002a46dced00b8576d945b3cf" name="a628f960002a46dced00b8576d945b3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628f960002a46dced00b8576d945b3cf">&#9670;&#160;</a></span>evaluateSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::evaluateSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a solution for the graph. This function evaluates a solution for the graph by calculating the total cost of the solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">solution</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7eaf9785bb3717ce22b6570286179fb1" name="a7eaf9785bb3717ce22b6570286179fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaf9785bb3717ce22b6570286179fb1">&#9670;&#160;</a></span>findEulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::findEulerianCircuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>multigraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an Eulerian circuit for the multigraph. This function finds an Eulerian circuit for the multigraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multigraph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>complexity: O(|E| + |V|) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a94298b826225b9f4a4a1ce7d27536c52" name="a94298b826225b9f4a4a1ce7d27536c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94298b826225b9f4a4a1ce7d27536c52">&#9670;&#160;</a></span>findMinimumSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; Graph::findMinimumSpanningTree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum spanning tree using Prim's algorithm. This function finds the minimum spanning tree (MST) of the graph using Prim's algorithm. It starts from a specified start vertex and iteratively adds the minimum-weight edges that connect the already visited vertices to the newly visited vertices. The function returns a vector of pairs representing the edges of the minimum spanning tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A reference to a vector to store the parent indices for each vertex in the MST. The parent vector is updated during the MST construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs representing the edges of the minimum spanning tree. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the graph is connected, undirected, and weighted. It uses a priority queue to efficiently select the minimum-weight edges. </dd>
<dd>
The complexity of this function is O(E log V), where E is the number of edges and V is the number of vertices in the graph. Prim's algorithm iterates over all vertices and edges once, and the priority queue operations take O(log V) time. </dd></dl>

</div>
</div>
<a id="afa7de765e6857b5c27c468d116b54303" name="afa7de765e6857b5c27c468d116b54303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7de765e6857b5c27c468d116b54303">&#9670;&#160;</a></span>findMinimumWeightMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::findMinimumWeightMatching </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>oddDegreeVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum weight matching for the graph. This function finds the minimum weight matching for the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">oddDegreeVertices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a089f7fc73ea9976295d387846ad36c69" name="a089f7fc73ea9976295d387846ad36c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f7fc73ea9976295d387846ad36c69">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dfcef08a9286cf144902cd7e56940ee" name="a7dfcef08a9286cf144902cd7e56940ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfcef08a9286cf144902cd7e56940ee">&#9670;&#160;</a></span>findVertexIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::findVertexIdx </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e9909acdfa72e74a26128514c8d4347" name="a8e9909acdfa72e74a26128514c8d4347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9909acdfa72e74a26128514c8d4347">&#9670;&#160;</a></span>findVerticesWithOddDegrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::findVerticesWithOddDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the vertices with odd degrees in the graph. This function finds the vertices with odd degrees in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="adef310ea9f68e12bd1f60c18fddad26d" name="adef310ea9f68e12bd1f60c18fddad26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef310ea9f68e12bd1f60c18fddad26d">&#9670;&#160;</a></span>generateNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; Graph::generateNeighbors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac352130e3587cea1598abbe6a1175384" name="ac352130e3587cea1598abbe6a1175384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac352130e3587cea1598abbe6a1175384">&#9670;&#160;</a></span>generateNeighborSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::generateNeighborSolution </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a neighboring solution based on a given solution. This function generates a neighboring solution by applying a random mutation to the given solution. The mutation can be one of four types: swap, deletion, reversal, or scramble. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>The current solution for which to generate a neighbor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A neighboring solution obtained by applying a random mutation to the given solution. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function creates a copy of the given solution and performs a random mutation on the copy. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afacb86b8087bea43a76f8efa604139b6" name="afacb86b8087bea43a76f8efa604139b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb86b8087bea43a76f8efa604139b6">&#9670;&#160;</a></span>generateRandomSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::generateRandomSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random solution for the graph. This function generates a random solution for the graph by randomly shuffling the vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>A random solution for the graph. </dd></dl>

</div>
</div>
<a id="a0a916c1d4af18fd3f97bb329840d632f" name="a0a916c1d4af18fd3f97bb329840d632f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a916c1d4af18fd3f97bb329840d632f">&#9670;&#160;</a></span>getBestCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getBestCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad179cbc8be49bddafc6dd56808b7303f" name="ad179cbc8be49bddafc6dd56808b7303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad179cbc8be49bddafc6dd56808b7303f">&#9670;&#160;</a></span>getBestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::getBestPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7a5db6e0f2ce3b90d05a7335cc064ed" name="af7a5db6e0f2ce3b90d05a7335cc064ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a5db6e0f2ce3b90d05a7335cc064ed">&#9670;&#160;</a></span>getEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge weight between two vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">destination</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abb5e0517e2979c54eebdafc2a9875e8f" name="abb5e0517e2979c54eebdafc2a9875e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5e0517e2979c54eebdafc2a9875e8f">&#9670;&#160;</a></span>getNumVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getNumVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a619ac583094079134074658e29463c0e" name="a619ac583094079134074658e29463c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619ac583094079134074658e29463c0e">&#9670;&#160;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7d78c739188d98a06e1ff3d79a584a2" name="ab7d78c739188d98a06e1ff3d79a584a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d78c739188d98a06e1ff3d79a584a2">&#9670;&#160;</a></span>isTabu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isTabu </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::deque&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tabuList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a solution is tabu. This function checks if a solution is tabu by comparing it with the solutions in the tabu list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td></td></tr>
    <tr><td class="paramname">tabuList</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the solution is tabu, false otherwise. </dd></dl>

</div>
</div>
<a id="aaff2dbf5f385f7b22894b9ec290c0eb4" name="aaff2dbf5f385f7b22894b9ec290c0eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff2dbf5f385f7b22894b9ec290c0eb4">&#9670;&#160;</a></span>isTabuAspirational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isTabuAspirational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::deque&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tabuList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>diversificationThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a solution is tabu aspirational. This function checks if a solution is tabu aspirational by comparing it with the solutions in the tabu list. A solution is tabu aspirational if its diversity with any of the solutions in the tabu list is greater than the diversification threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td></td></tr>
    <tr><td class="paramname">tabuList</td><td></td></tr>
    <tr><td class="paramname">diversificationThreshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the solution is tabu aspirational, false otherwise. </dd></dl>

</div>
</div>
<a id="ac6c8ef3f68bab7aa3c826b6f755396c7" name="ac6c8ef3f68bab7aa3c826b6f755396c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c8ef3f68bab7aa3c826b6f755396c7">&#9670;&#160;</a></span>MST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::MST </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a minimum spanning tree for the graph. This function constructs a minimum spanning tree for the graph. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a716e0acd93275a00a011bfa5f6c624d0" name="a716e0acd93275a00a011bfa5f6c624d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716e0acd93275a00a011bfa5f6c624d0">&#9670;&#160;</a></span>nearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::nearestNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the best path using the nearest neighbor algorithm. This function calculates the total distance of a route using the nearest neighbor algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>complexity: O(V^2) V is the number of vertices in the graph; </dd></dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa62e7d089926d34b8cac9b7cd3ccd88b" name="aa62e7d089926d34b8cac9b7cd3ccd88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62e7d089926d34b8cac9b7cd3ccd88b">&#9670;&#160;</a></span>removeDuplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::removeDuplicates </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>eulerianCircuit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicate vertices from the Eulerian circuit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eulerianCircuit</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a961b73cac0c31b9f472b9441a713d1f2" name="a961b73cac0c31b9f472b9441a713d1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961b73cac0c31b9f472b9441a713d1f2">&#9670;&#160;</a></span>simulatedAnnealing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::simulatedAnnealing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initialTemperature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coolingRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the Simulated Annealing algorithm on the graph. This function applies the Simulated Annealing algorithm to find an optimal solution for the given graph. It starts with an initial solution and iteratively explores neighboring solutions by accepting or rejecting them based on a probability. The algorithm aims to converge towards the global optimum by gradually decreasing the acceptance probability with each iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph on which to perform the Simulated Annealing algorithm. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>The maximum number of iterations to perform. </td></tr>
    <tr><td class="paramname">initialTemperature</td><td>The initial temperature for the annealing process. </td></tr>
    <tr><td class="paramname">coolingRate</td><td>The cooling rate for the annealing process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a800d17f2cb4a6780513838aaf93c0d" name="a5a800d17f2cb4a6780513838aaf93c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a800d17f2cb4a6780513838aaf93c0d">&#9670;&#160;</a></span>tabuSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tabuSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tabuListSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterationsWithoutImprovement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Tabu Search algorithm to find an improved solution. This function implements the Tabu Search algorithm to find an improved solution for a given graph. It iteratively generates neighboring solutions and evaluates their costs. The algorithm maintains a tabu list to prevent revisiting previously visited solutions. If a better neighbor solution is found and it is not in the tabu list, it becomes the current solution. The algorithm stops when either the maximum number of iterations is reached or no improvement is made for a certain number of iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A reference to the graph on which to perform Tabu Search. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>The maximum number of iterations to perform. </td></tr>
    <tr><td class="paramname">tabuListSize</td><td>The size of the tabu list. </td></tr>
    <tr><td class="paramname">maxIterationsWithoutImprovement</td><td>The maximum number of iterations without improvement to stop the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The complexity of this function depends on the size of the tabu list, the number of iterations. </dd></dl>

</div>
</div>
<a id="a74ac3915ab78762e537d45657e30429b" name="a74ac3915ab78762e537d45657e30429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ac3915ab78762e537d45657e30429b">&#9670;&#160;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::triangularApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the total distance of a route using the triangular approximation algorithm. This function calculates the total distance of a route using the triangular approximation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>complexity: O(E log V) E is the number of edges in the graph and V is the number of vertices in the graph; </dd></dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9f00b32afb4745db9d4d415003500579" name="a9f00b32afb4745db9d4d415003500579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f00b32afb4745db9d4d415003500579">&#9670;&#160;</a></span>bestCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::bestCost = std::numeric_limits&lt;double&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4e099ad9b42cb93771db6b434bc6693" name="ad4e099ad9b42cb93771db6b434bc6693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e099ad9b42cb93771db6b434bc6693">&#9670;&#160;</a></span>bestPath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Graph::bestPath</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e61864da69191c1896a25a708d1a02d" name="a9e61864da69191c1896a25a708d1a02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e61864da69191c1896a25a708d1a02d">&#9670;&#160;</a></span>distMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double** Graph::distMatrix = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae09699c3616af3ebfcb1eb045f2b62" name="a3ae09699c3616af3ebfcb1eb045f2b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae09699c3616af3ebfcb1eb045f2b62">&#9670;&#160;</a></span>pathMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int** Graph::pathMatrix = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9b0a6d8ad43c5eabaca5a7140bcc8b6" name="aa9b0a6d8ad43c5eabaca5a7140bcc8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b0a6d8ad43c5eabaca5a7140bcc8b6">&#9670;&#160;</a></span>vertexSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_vertex.html">Vertex</a> *&gt; Graph::vertexSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/data_structures/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>src/data_structures/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
